/*******************************************************************************
 * Copyright (c) 2016 Benjamin Weißenfels.
 *
 * This program is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation, either version 3
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.
 * If not, see <http://www.gnu.org/licenses/>.
 *
 * Contributors:
 *     @author Benjamin Weißenfels <bw[at]sernet[dot]de> - initial API and implementation
 ******************************************************************************/
package sernet.verinice.service.linktable.generator;

import org.apache.log4j.Logger;

import sernet.verinice.interfaces.graph.Edge;
import sernet.verinice.interfaces.graph.TraversalFilter;
import sernet.verinice.interfaces.graph.VeriniceGraph;
import sernet.verinice.model.common.CnATreeElement;
import sernet.verinice.model.iso27k.Asset;
import sernet.verinice.model.iso27k.IncidentScenario;
import sernet.verinice.service.linktable.generator.mergepath.VqlAst;
import sernet.verinice.service.linktable.generator.mergepath.VqlEdge;
import sernet.verinice.service.linktable.generator.mergepath.VqlNode;

/**
 * Flatten a {@VeriniceGraph} path to a list.
 *
 *
 * @author Benjamin Weißenfels <bw[at]sernet[dot]de>
 *
 */
final class LtrPrintRowsTraversalListener implements sernet.verinice.interfaces.graph.TraversalListener {

    private static final Logger LOG = Logger.getLogger(LtrPrintRowsTraversalListener.class);

    private VeriniceGraphResult result;

    private VqlContext vqlContext;

    /**
     * Flatten a {@VeriniceGraph} path to a list. The result is available with
     *
     *
     * @param path
     *            A path generated by {@link VqlAst}.
     * @param filter
     *            Use this filter for detecting leafs in the tree
     * 
     * @param graph
     *            The verinice data graph.
     * 
     * @param columnHeader
     *            A list of all header of a LTR-Table
     */
    LtrPrintRowsTraversalListener(VqlContext vqlContext, TraversalFilter filter, VeriniceGraph graph, VeriniceGraphResult result) {
        this.vqlContext = vqlContext;
        this.result = result;
    }

    @Override
    public void nodeTraversed(CnATreeElement node, Edge incoming, int depth) {

        if (LOG.isDebugEnabled()) {
            LOG.debug("traversed node: " + node.getTitle() + ":" + node.getTypeId());
        }

        CnATreeElement source;

        if (incoming == null) {
            source = node;
        } else {
            source = incoming.getSource() == node ? node : incoming.getTarget();
        }

        if (vqlContext.getCurrentNode().isMatch()) {
            printRow(vqlContext.getCurrentNode(), vqlContext.getCurrentEdge(), source, incoming, depth);
        }
    }

    @Override
    public void nodeFinished(CnATreeElement node, int depth) {

        if (vqlContext.getCurrentNode().isMatch()) {
            result.removeValue();
        }

        vqlContext.stepBack();

        if (LOG.isDebugEnabled()) {
            LOG.debug("finished node: " + node.getTitle() + ":" + node.getTypeId());
        }
    }

    @Override
    public void edgeTraversed(CnATreeElement source, CnATreeElement target, Edge edge, int depth) {
        VqlNode nextNode = vqlContext.getNextNode(source, edge, target);
        vqlContext.setCurrentNode(nextNode);
        LOG.debug("traversed edge: " + edge + " depth: " + depth);
    }

    /**
     * Returns a row, which is one valid path through the {@link VeriniceGraph}.
     * The map containes a key, which is the column path header:
     *
     * <pre>
     * 1. (assetgroup > asset.title -> Computer 1, assetgroup.title -> IT)
     * 2. (assetgroup > asset.title -> Computer 2, assetgroup.title -> IT)
     * </pre>
     *
     */
    public VeriniceGraphResult getResult() {
        return result;
    }

    private void printRow(VqlNode vqlNode, VqlEdge vqlEdge, CnATreeElement element, Edge edge, int depth) {
        if (vqlNode.isMatch()) {
            result.addValue(vqlNode, vqlEdge, edge, element, depth);
        }
    }
    
    public static boolean isAssetAndSzenario(CnATreeElement dependant, CnATreeElement dependency) {
        try {
            return (Asset.TYPE_ID.equals(dependant.getTypeId()) && IncidentScenario.TYPE_ID.equals(dependency.getTypeId()))
                   || (Asset.TYPE_ID.equals(dependency.getTypeId()) && IncidentScenario.TYPE_ID.equals(dependant.getTypeId()));
        } catch(Exception e) {
            LOG.error("Error while checking link.", e); //$NON-NLS-1$
            return false;
        }
    }

}